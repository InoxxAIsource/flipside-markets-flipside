/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type { BaseContract, BigNumberish, BytesLike, FunctionFragment, Result, Interface, EventFragment, AddressLike, ContractRunner, ContractMethod, Listener } from "ethers"
import type { TypedContractEvent, TypedDeferredTopicFilter, TypedEventLog, TypedLogDescription, TypedListener, TypedContractMethod } from "./common.js"
  
export declare namespace ProxyWallet {
      
    export type CallStruct = {to: AddressLike, data: BytesLike, value: BigNumberish}

    export type CallStructOutput = [to: string, data: string, value: bigint] & {to: string, data: string, value: bigint }
  
    }

  export interface ProxyWalletInterface extends Interface {
    getFunction(nameOrSignature: "DOMAIN_SEPARATOR" | "META_TRANSACTION_TYPEHASH" | "execute" | "executeBatch" | "executeMetaTransaction" | "getNonce" | "getOwner" | "nonces" | "onERC1155BatchReceived" | "onERC1155Received" | "owner" | "supportsInterface"): FunctionFragment;

    getEvent(nameOrSignatureOrTopic: "ExecutionFailure" | "ExecutionSuccess" | "MetaTransactionExecuted"): EventFragment;

    encodeFunctionData(functionFragment: 'DOMAIN_SEPARATOR', values?: undefined): string;
encodeFunctionData(functionFragment: 'META_TRANSACTION_TYPEHASH', values?: undefined): string;
encodeFunctionData(functionFragment: 'execute', values: [AddressLike, BytesLike, BigNumberish]): string;
encodeFunctionData(functionFragment: 'executeBatch', values: [ProxyWallet.CallStruct[]]): string;
encodeFunctionData(functionFragment: 'executeMetaTransaction', values: [AddressLike, AddressLike, BytesLike, BytesLike, BigNumberish]): string;
encodeFunctionData(functionFragment: 'getNonce', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'getOwner', values?: undefined): string;
encodeFunctionData(functionFragment: 'nonces', values: [AddressLike]): string;
encodeFunctionData(functionFragment: 'onERC1155BatchReceived', values: [AddressLike, AddressLike, BigNumberish[], BigNumberish[], BytesLike]): string;
encodeFunctionData(functionFragment: 'onERC1155Received', values: [AddressLike, AddressLike, BigNumberish, BigNumberish, BytesLike]): string;
encodeFunctionData(functionFragment: 'owner', values?: undefined): string;
encodeFunctionData(functionFragment: 'supportsInterface', values: [BytesLike]): string;

    decodeFunctionResult(functionFragment: 'DOMAIN_SEPARATOR', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'META_TRANSACTION_TYPEHASH', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'execute', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'executeBatch', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'executeMetaTransaction', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getNonce', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'getOwner', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'nonces', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'onERC1155BatchReceived', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'onERC1155Received', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result;
decodeFunctionResult(functionFragment: 'supportsInterface', data: BytesLike): Result;
  }

  
    export namespace ExecutionFailureEvent {
      export type InputTuple = [to: AddressLike, value: BigNumberish, data: BytesLike];
      export type OutputTuple = [to: string, value: bigint, data: string];
      export interface OutputObject {to: string, value: bigint, data: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace ExecutionSuccessEvent {
      export type InputTuple = [to: AddressLike, value: BigNumberish, data: BytesLike, returnData: BytesLike];
      export type OutputTuple = [to: string, value: bigint, data: string, returnData: string];
      export interface OutputObject {to: string, value: bigint, data: string, returnData: string };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

    export namespace MetaTransactionExecutedEvent {
      export type InputTuple = [user: AddressLike, target: AddressLike, nonce: BigNumberish];
      export type OutputTuple = [user: string, target: string, nonce: bigint];
      export interface OutputObject {user: string, target: string, nonce: bigint };
      export type Event = TypedContractEvent<InputTuple, OutputTuple, OutputObject>
      export type Filter = TypedDeferredTopicFilter<Event>
      export type Log = TypedEventLog<Event>
      export type LogDescription = TypedLogDescription<Event>
    }

  

  export interface ProxyWallet extends BaseContract {
    
    connect(runner?: ContractRunner | null): ProxyWallet;
    waitForDeployment(): Promise<this>;

    interface: ProxyWalletInterface;

    
  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined,
  ): Promise<Array<TypedEventLog<TCEvent>>>
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  on<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>
  
  once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>
  once<TCEvent extends TypedContractEvent>(filter: TypedDeferredTopicFilter<TCEvent>, listener: TypedListener<TCEvent>): Promise<this>

  listeners<TCEvent extends TypedContractEvent>(
    event: TCEvent
  ): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>
  removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>


    
    
    DOMAIN_SEPARATOR: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    META_TRANSACTION_TYPEHASH: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    execute: TypedContractMethod<
      [to: AddressLike, data: BytesLike, value: BigNumberish, ],
      [string],
      'payable'
    >
    

    
    executeBatch: TypedContractMethod<
      [calls: ProxyWallet.CallStruct[], ],
      [string[]],
      'payable'
    >
    

    
    executeMetaTransaction: TypedContractMethod<
      [user: AddressLike, target: AddressLike, data: BytesLike, signature: BytesLike, deadline: BigNumberish, ],
      [string],
      'payable'
    >
    

    
    getNonce: TypedContractMethod<
      [user: AddressLike, ],
      [bigint],
      'view'
    >
    

    
    getOwner: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    nonces: TypedContractMethod<
      [arg0: AddressLike, ],
      [bigint],
      'view'
    >
    

    
    onERC1155BatchReceived: TypedContractMethod<
      [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish[], arg3: BigNumberish[], arg4: BytesLike, ],
      [string],
      'view'
    >
    

    
    onERC1155Received: TypedContractMethod<
      [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish, arg3: BigNumberish, arg4: BytesLike, ],
      [string],
      'view'
    >
    

    
    owner: TypedContractMethod<
      [],
      [string],
      'view'
    >
    

    
    supportsInterface: TypedContractMethod<
      [interfaceId: BytesLike, ],
      [boolean],
      'view'
    >
    


    getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;

    getFunction(nameOrSignature: 'DOMAIN_SEPARATOR'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'META_TRANSACTION_TYPEHASH'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'execute'): TypedContractMethod<
      [to: AddressLike, data: BytesLike, value: BigNumberish, ],
      [string],
      'payable'
    >;
getFunction(nameOrSignature: 'executeBatch'): TypedContractMethod<
      [calls: ProxyWallet.CallStruct[], ],
      [string[]],
      'payable'
    >;
getFunction(nameOrSignature: 'executeMetaTransaction'): TypedContractMethod<
      [user: AddressLike, target: AddressLike, data: BytesLike, signature: BytesLike, deadline: BigNumberish, ],
      [string],
      'payable'
    >;
getFunction(nameOrSignature: 'getNonce'): TypedContractMethod<
      [user: AddressLike, ],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'getOwner'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'nonces'): TypedContractMethod<
      [arg0: AddressLike, ],
      [bigint],
      'view'
    >;
getFunction(nameOrSignature: 'onERC1155BatchReceived'): TypedContractMethod<
      [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish[], arg3: BigNumberish[], arg4: BytesLike, ],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'onERC1155Received'): TypedContractMethod<
      [arg0: AddressLike, arg1: AddressLike, arg2: BigNumberish, arg3: BigNumberish, arg4: BytesLike, ],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'owner'): TypedContractMethod<
      [],
      [string],
      'view'
    >;
getFunction(nameOrSignature: 'supportsInterface'): TypedContractMethod<
      [interfaceId: BytesLike, ],
      [boolean],
      'view'
    >;

    getEvent(key: 'ExecutionFailure'): TypedContractEvent<ExecutionFailureEvent.InputTuple, ExecutionFailureEvent.OutputTuple, ExecutionFailureEvent.OutputObject>;
getEvent(key: 'ExecutionSuccess'): TypedContractEvent<ExecutionSuccessEvent.InputTuple, ExecutionSuccessEvent.OutputTuple, ExecutionSuccessEvent.OutputObject>;
getEvent(key: 'MetaTransactionExecuted'): TypedContractEvent<MetaTransactionExecutedEvent.InputTuple, MetaTransactionExecutedEvent.OutputTuple, MetaTransactionExecutedEvent.OutputObject>;

    filters: {
      
      'ExecutionFailure(address,uint256,bytes)': TypedContractEvent<ExecutionFailureEvent.InputTuple, ExecutionFailureEvent.OutputTuple, ExecutionFailureEvent.OutputObject>;
      ExecutionFailure: TypedContractEvent<ExecutionFailureEvent.InputTuple, ExecutionFailureEvent.OutputTuple, ExecutionFailureEvent.OutputObject>;
    

      'ExecutionSuccess(address,uint256,bytes,bytes)': TypedContractEvent<ExecutionSuccessEvent.InputTuple, ExecutionSuccessEvent.OutputTuple, ExecutionSuccessEvent.OutputObject>;
      ExecutionSuccess: TypedContractEvent<ExecutionSuccessEvent.InputTuple, ExecutionSuccessEvent.OutputTuple, ExecutionSuccessEvent.OutputObject>;
    

      'MetaTransactionExecuted(address,address,uint256)': TypedContractEvent<MetaTransactionExecutedEvent.InputTuple, MetaTransactionExecutedEvent.OutputTuple, MetaTransactionExecutedEvent.OutputObject>;
      MetaTransactionExecuted: TypedContractEvent<MetaTransactionExecutedEvent.InputTuple, MetaTransactionExecutedEvent.OutputTuple, MetaTransactionExecutedEvent.OutputObject>;
    
    };
  }